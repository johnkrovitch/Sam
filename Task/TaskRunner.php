<?php

namespace JK\Sam\Task;

use Exception;
use JK\Sam\File\Locator;
use JK\Sam\Filter\FilterInterface;
use SplFileInfo;

class TaskRunner
{
    /**
     * @var FilterInterface[]
     */
    protected $filters;

    /**
     * @var Locator
     */
    protected $locator;

    /**
     * @var bool
     */
    protected $isDebug;

    /**
     * TaskRunner constructor.
     *
     * @param FilterInterface[] $filters
     * @param Locator $locator
     * @param bool $isDebug
     */
    public function __construct(array $filters, Locator $locator, $isDebug = false)
    {
        $this->filters = $filters;
        $this->locator = $locator;
        $this->isDebug = $isDebug;
    }

    /**
     * Run a task, load its sources before and call the clean method on the filter.
     *
     * @param Task $task
     * @throws Exception
     */
    public function run(Task $task)
    {
        // get configured filters for this task
        $filters = $task
            ->getConfiguration()
            ->getParameter('filters');

        // get sources files
        $sources = $this->fetchSources($task);
        $destinations = $this->fetchDestinations($task);

        foreach ($filters as $filterName) {
            // get current configured filter
            $filter = $this->getFilter($filterName);

            // filter the files supported by this filter
            $filteredSources = $this->filterSources($sources, $filter);

            // apply the filter
            $updatedSources = $filter->run($filteredSources, $destinations);

            // update new sources if exists
            if ($updatedSources === null) {
                $updatedSources = [];
            }
            $sources = $this->updateSources($sources, $filteredSources, $updatedSources);
        }

        if (!$this->isDebug) {
            foreach ($filters as $filterName) {
                // get current configured filter
                $filter = $this->getFilter($filterName);

                // clean the files generated by the filter
                $filter->clean();
            }
        }
    }

    /**
     * Return a filter by its name. Throw an exception if it is not exists.
     *
     * @param string $name
     * @return FilterInterface
     * @throws Exception
     */
    protected function getFilter($name)
    {
        // filters must exists in configured filters
        if (!array_key_exists($name, $this->filters)) {
            throw new Exception('Invalid filter '.$name.'. Check your mapping configuration');
        }

        return $this->filters[$name];
    }

    /**
     * Fetch the source files from the task and return and array of SplInfo.
     *
     * @param Task $task
     * @return array
     */
    protected function fetchSources(Task $task)
    {
        $sources = [];

        foreach ($task->getSources() as $source) {
            // locate new resource and merge them to the existing sources
            $sources = array_merge($sources, $this->locator->locate($source));
        }

        return $sources;
    }

    /**
     * Fetch the destination files from the task and return and array of SplInfo.
     *
     * @param Task $task
     * @return SplFileInfo[]
     */
    protected function fetchDestinations(Task $task)
    {
        $sources = [];

        foreach ($task->getDestinations() as $source) {
            // locate new resource and merge them to the existing sources
            $sources[] = new SplFileInfo($source);
        }

        return $sources;
    }

    /**
     * Filter only the sources supported by the current filter.
     *
     * @param SplFileInfo[] $sources
     * @param FilterInterface $filter
     * @return array
     * @throws Exception
     */
    protected function filterSources(array $sources, FilterInterface $filter)
    {
        $filteredSources = [];

        // if the filter supports no extension, there is an error
        if (!is_array($filter->getSupportedExtensions()) || !count($filter->getSupportedExtensions())) {
            throw new Exception('No supported extensions found for the filter '.$filter->getName());
        }

        foreach ($sources as $source) {
            $isExtensionSupported = in_array($source->getExtension(), $filter->getSupportedExtensions());
            $supportAllExtensions = in_array('*', $filter->getSupportedExtensions());

            if ($isExtensionSupported || $supportAllExtensions) {
                $filteredSources[] = $this
                    ->locator
                    ->getNormalizer()
                    ->normalize($source);
            }
        }

        return $filteredSources;
    }

    /**
     * Remove the filtered files from the sources, and merge with the new ones.
     *
     * @param SplFileInfo[] $originalSources
     * @param SplFileInfo[] $filteredSources
     * @param SplFileInfo[] $updatedSources
     * @return SplFileInfo[]
     * @throws Exception
     */
    protected function updateSources(array $originalSources, array $filteredSources, array $updatedSources)
    {
        $sources = [];
        $filteredPath = [];

        foreach ($filteredSources as $filteredSource) {
            $filteredPath[] = $filteredSource->getPath();
        }
        // keep only the not filtered files
        foreach ($originalSources as $originalSource) {

            // if an original source is not used by the current filter, we keep it in the source list
            if (!in_array($originalSource->getPath(), $filteredPath)) {
                $sources[] = $originalSource;
            }
        }
        // check updated files
        foreach ($updatedSources as $index => $source) {
            if (is_string($source)) {
                $updatedSources[$index] = new SplFileInfo($source);
            } else if (!($source instanceof SplFileInfo)) {
                throw new Exception('Invalid source file type '.gettype($source));
            }
        }
        // merge with the new sources
        $sources = array_merge($sources, $updatedSources);

        return $sources;
    }
}
